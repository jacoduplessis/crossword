/* App.html generated by Svelte v2.15.0 */
var Crossword = (function() { "use strict";

	function range(n) {
  return Array.from(Array(n).keys())
}

function flatten(A) {
  return A.reduce((agg, a) => agg.concat(a), [])
}

function transposeTables(numRows, numColumns) {

  const N = numRows * numColumns
  const A = range(N)
  const columns = Array(numColumns).fill(0).map(() => [])

  A.forEach((a, i) => {
    columns[i % numRows].push(a)
  })

  const rotate90 = flatten(columns.map(col => col.slice(0).reverse()))
  const rotate270 = rotate90.slice(0).reverse()
  const rotate180 = A.slice(0).reverse()

  return {
    "90": rotate90,
    "180": rotate180,
    "270": rotate270,
  }
}

function size({rows, columns}) {
		return rows * columns;
	}

	function transpose({symmetric, rows, columns}) {
  if (!symmetric || (rows !== columns)) return {}
  return transposeTables(rows, columns)
}

	function shareURL({rows, columns, values}) {
  return document.location.origin +
    document.location.pathname + `?r=${rows}&c=${columns}&v=${values.join('')}`
};

	function data() {
  return {
    rows: 13,
    columns: 13,
    values: [],
    blacks: [],
    numbers: [],
    symmetric: true,
    info: '',
    showShare: false,
    showOptions: false,
    showHelp: false,
    lastMovementDirection: null,
  }
};

	var methods = {
  indexAbove(index) {
    const { columns } = this.get()
    return Math.max(0, index - columns)
  },
  indexBelow(index) {
    const {size, columns} = this.get()
    return Math.min(size, index + columns)
  },
  indexRight(index) {
    const {size} = this.get()
    return Math.min(size, index + 1)
  },
  indexLeft(index) {
    return Math.max(0, index - 1)
  },
  moveFocus(event, index) {
    const keyCode = event.keyCode
    if (keyCode === 37) this.focusLeft(index)
    else if (keyCode === 38) this.focusUp(index)
    else if (keyCode === 39) this.focusRight(index)
    else if (keyCode === 40) this.focusDown(index)
  },
  focusDown(index) {
    this.focus(this.indexBelow(index))
  },
  focusUp(index) {
    this.focus(this.indexAbove((index)))
  },
  focusRight(index) {
    this.focus(this.indexRight(index))
  },
  focusLeft(index) {
    this.focus(this.indexLeft(index))
  },
  rowIndex(index) {
    const {columns} = this.get()
    return Math.floor(index / columns)
  },
  columnIndex(index) {
    const {columns } = this.get()
    return index % columns
  },
  cellRight(index) {
    const {columns, blacks} = this.get()
    return this.columnIndex(index) === columns - 1 ? false : !blacks[this.indexRight(index)]
  },
  cellBelow(index) {
    const {rows,blacks} = this.get()
    return this.rowIndex(index) === rows - 1 ? false : !blacks[this.indexBelow(index)]
  },
  cellLeft(index) {
    const {blacks} = this.get()
    return this.columnIndex(index) === 0 ? false : !blacks[this.indexLeft(index)]
  },
  cellAbove(index) {
    const {blacks} = this.get()
    return this.rowIndex(index) === 0 ? false : !blacks[this.indexAbove(index)]
  },
  openCellRight(index) { return this.cellRight(index) && this.get().values[this.indexRight(index)] === '-'},
  openCellBelow(index) { return this.cellBelow(index) && this.get().values[this.indexBelow(index)] === '-'},

  didFocus(event, index) {
    event.target.select()
    const info = `
index: ${index}
row: ${this.rowIndex(index)}
column: ${this.columnIndex(index)}
cellLeft: ${this.cellLeft(index)}
cellRight: ${this.cellRight(index)}
cellAbove: ${this.cellAbove(index)}
cellBelow: ${this.cellBelow(index)}
openRight: ${this.openCellRight(index)}
openBelow: ${this.openCellBelow(index)}
black: ${this.get().blacks[index]}
indexBelow: ${this.indexBelow(index)}
lastDir: ${this.get().lastMovementDirection}
`
    this.set({info})
  },
  focus(index) {
    const el = document.querySelector(`#cell-${index}`)
    if (el) {
      el.focus()
      el.select()
    }
  },
  moveToNext(index) {
    if (!this.openCellRight(index) && this.openCellBelow(index)) {
      this.set({lastMovementDirection: 'down'})
      return this.focus(this.indexBelow(index))
    }
    if (!this.cellRight(index) && this.cellBelow(index)) {
      this.set({lastMovementDirection: 'down'})
      return this.focus(this.indexBelow(index))
    }
    if (this.cellRight(index) && this.cellBelow(index) && this.get().lastMovementDirection === 'down') {
      this.set({lastMovementDirection: 'down'})
      return this.focus(this.indexBelow(index))
    }
    this.set({lastMovementDirection: 'right'})
    this.focus(this.indexRight(index))
  },
  process(event, index) {

    const value = event.target.value.trim() || "-"
    const {blacks, values} = this.get()

    values.splice(index, 1, value)
    this.set({values})
    this.moveToNext(index)
    const wasBlack = !!blacks[index]
    const black = value === '.'
    if ((black && !wasBlack) || (!black && wasBlack)) {
      this.processBlack(index, black)
      this.updateNumbers()
    }
  },
  processBlack(index, black) {
    const {symmetric, blacks, transpose, values} = this.get()
   
    blacks.splice(index, 1, black)
    if (symmetric) {
      const other = [
        transpose['90'][index],
        transpose['180'][index],
        transpose['270'][index],
      ]
      const replacement = black ? '.' : '-'
      other.forEach(i => {
        blacks.splice(i, 1, black)
        values.splice(i, 1, replacement)
      })
      this.set({values})
    }
    this.set({blacks})
  },

  updateGrid() {
    const {rows,columns,symmetric} = this.get()
    if (symmetric && rows !== columns) this.set({symmetric: false})
    this.refs.grid.style['grid-template-rows'] = `repeat(${rows}, 40px)`
    this.refs.grid.style['grid-template-columns'] = `repeat(${columns}, 40px)`
  },
  clear() {
    const {size } = this.get()
     this.set({
      values: Array(size).fill("-"),
      blacks: Array(size).fill(false),
      numbers: Array(size).fill(0),
    })
  },
  save(event) {
    const btn = event.target
    const {rows,columns,values} = this.get()
    localStorage.setItem('backup', JSON.stringify({rows, columns, values}))
    btn.style.backgroundColor = 'darkseagreen'
    setTimeout(() => btn.style.backgroundColor = '', 1000)
  },
  share() {
    const {showShare} = this.get()
    if (showShare) return this.set({showShare: false})
    this.set({showShare: true})
    setTimeout(() => this.refs.share.select(), 10)
  },
  copy() {
    this.refs.share.select()
    document.execCommand('copy')
  },
  loadFromStorage() {
    const {rows,columns,values} = JSON.parse(localStorage.getItem('backup'))
    this.load(rows, columns, values)
  },
  load(rows, columns, values) {
    this.set({
      rows,
      columns,
      values,
      blacks: values.map(v => v === '.'),
    })
    this.updateNumbers()
  },
  updateNumbers() {

    let counter = 1;
    const {blacks,size} = this.get()
    const numbers = Array(size).fill(0)
    blacks.forEach((black, index) => {
      if (black) return 0

      // horizontal || vertical
      if ((this.cellRight(index) && !this.cellLeft(index)) ||
        (this.cellBelow(index) && !this.cellAbove(index))) {
        numbers[index] = counter
        counter++
      }

    })
    this.set({numbers})
  }
};

	function oncreate() {
  this.clear()
  const u = new URL(document.location)
  const r = u.searchParams.get('r')
  const c = u.searchParams.get('c')
  const v = u.searchParams.get('v')
  if (v && r && c) {
    this.load(parseInt(r), parseInt(c), v.split(''))
  }
};

	function onstate({changed,current,previous}) {
  if (changed.rows || changed.columns) {
    const callback = this.updateGrid.bind(this)
    if (!this.refs.grid) setTimeout(callback, 200)
    else callback()
  }
};

	function keyup_handler(event) {
		const { component, ctx } = this._svelte;

		component.moveFocus(event, ctx.index);
	}

	function focus_handler(event) {
		const { component, ctx } = this._svelte;

		component.didFocus(event, ctx.index);
	}

	function input_handler(event) {
		const { component, ctx } = this._svelte;

		component.process(event, ctx.index);
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.val = list[i];
		child_ctx.each_value = list;
		child_ctx.index = i;
		return child_ctx;
	}

	function create_main_fragment(component, ctx) {
		var div0, button0, text0, button0_class_value, text1, button1, text3, button2, text5, button3, text7, button4, text8, button4_class_value, text9, button5, text10, button5_class_value, text11, text12, text13, text14, pre, text15, text16, div1;

		function click_handler(event) {
			component.set({showOptions: !ctx.showOptions});
		}

		function click_handler_1(event) {
			component.clear();
		}

		function click_handler_2(event) {
			component.save(event);
		}

		function click_handler_3(event) {
			component.loadFromStorage();
		}

		function click_handler_4(event) {
			component.set({showHelp: !ctx.showHelp});
		}

		function click_handler_5(event) {
			component.share();
		}

		var if_block0 = (ctx.showOptions) && create_if_block_3(component, ctx);

		var if_block1 = (ctx.showShare) && create_if_block_2(component, ctx);

		var if_block2 = (ctx.showHelp) && create_if_block_1(component, ctx);

		var each_value = ctx.values.slice(0, ctx.size);

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c() {
				div0 = createElement("div");
				button0 = createElement("button");
				text0 = createText("options");
				text1 = createText("\n  ");
				button1 = createElement("button");
				button1.textContent = "clear";
				text3 = createText("\n  ");
				button2 = createElement("button");
				button2.textContent = "save";
				text5 = createText("\n  ");
				button3 = createElement("button");
				button3.textContent = "load";
				text7 = createText("\n  ");
				button4 = createElement("button");
				text8 = createText("help");
				text9 = createText("\n  ");
				button5 = createElement("button");
				text10 = createText("share");
				text11 = createText("\n\n");
				if (if_block0) if_block0.c();
				text12 = createText("\n\n");
				if (if_block1) if_block1.c();
				text13 = createText("\n\n");
				if (if_block2) if_block2.c();
				text14 = createText("\n\n");
				pre = createElement("pre");
				text15 = createText(ctx.info);
				text16 = createText("\n\n");
				div1 = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				addListener(button0, "click", click_handler);
				button0.className = button0_class_value = "" + (ctx.showOptions ? 'active' : '') + " svelte-18cs1n8";
				addListener(button1, "click", click_handler_1);
				button1.className = "svelte-18cs1n8";
				addListener(button2, "click", click_handler_2);
				button2.className = "svelte-18cs1n8";
				addListener(button3, "click", click_handler_3);
				button3.className = "svelte-18cs1n8";
				addListener(button4, "click", click_handler_4);
				button4.className = button4_class_value = "" + (ctx.showHelp ? 'active' : '') + " svelte-18cs1n8";
				addListener(button5, "click", click_handler_5);
				button5.className = button5_class_value = "" + (ctx.showShare ? 'active' : '') + " svelte-18cs1n8";
				setStyle(div0, "text-align", "center");
				setStyle(div0, "margin-bottom", "1rem");
				div0.className = "svelte-18cs1n8";
				setStyle(pre, "position", "fixed");
				setStyle(pre, "left", "10px");
				setStyle(pre, "top", "10px");
				pre.className = "svelte-18cs1n8";
				div1.className = "grid svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, div0, anchor);
				append(div0, button0);
				append(button0, text0);
				append(div0, text1);
				append(div0, button1);
				append(div0, text3);
				append(div0, button2);
				append(div0, text5);
				append(div0, button3);
				append(div0, text7);
				append(div0, button4);
				append(button4, text8);
				append(div0, text9);
				append(div0, button5);
				append(button5, text10);
				insert(target, text11, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text12, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text13, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, text14, anchor);
				insert(target, pre, anchor);
				append(pre, text15);
				insert(target, text16, anchor);
				insert(target, div1, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div1, null);
				}

				component.refs.grid = div1;
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if ((changed.showOptions) && button0_class_value !== (button0_class_value = "" + (ctx.showOptions ? 'active' : '') + " svelte-18cs1n8")) {
					button0.className = button0_class_value;
				}

				if ((changed.showHelp) && button4_class_value !== (button4_class_value = "" + (ctx.showHelp ? 'active' : '') + " svelte-18cs1n8")) {
					button4.className = button4_class_value;
				}

				if ((changed.showShare) && button5_class_value !== (button5_class_value = "" + (ctx.showShare ? 'active' : '') + " svelte-18cs1n8")) {
					button5.className = button5_class_value;
				}

				if (ctx.showOptions) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_3(component, ctx);
						if_block0.c();
						if_block0.m(text12.parentNode, text12);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.showShare) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_2(component, ctx);
						if_block1.c();
						if_block1.m(text13.parentNode, text13);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.showHelp) {
					if (!if_block2) {
						if_block2 = create_if_block_1(component, ctx);
						if_block2.c();
						if_block2.m(text14.parentNode, text14);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (changed.info) {
					setData(text15, ctx.info);
				}

				if (changed.blacks || changed.values || changed.size || changed.numbers) {
					each_value = ctx.values.slice(0, ctx.size);

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div1, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div0);
				}

				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
				removeListener(button2, "click", click_handler_2);
				removeListener(button3, "click", click_handler_3);
				removeListener(button4, "click", click_handler_4);
				removeListener(button5, "click", click_handler_5);
				if (detach) {
					detachNode(text11);
				}

				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text12);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text13);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(text14);
					detachNode(pre);
					detachNode(text16);
					detachNode(div1);
				}

				destroyEach(each_blocks, detach);

				if (component.refs.grid === div1) component.refs.grid = null;
			}
		};
	}

	// (10:0) {#if showOptions}
	function create_if_block_3(component, ctx) {
		var div, label0, text1, input0, input0_updating = false, text2, label1, text4, input1, input1_updating = false, text5, label2, text7, input2, input2_disabled_value;

		function input0_input_handler() {
			input0_updating = true;
			component.set({ rows: toNumber(input0.value) });
			input0_updating = false;
		}

		function input1_input_handler() {
			input1_updating = true;
			component.set({ columns: toNumber(input1.value) });
			input1_updating = false;
		}

		function input2_change_handler() {
			component.set({ symmetric: input2.checked });
		}

		return {
			c() {
				div = createElement("div");
				label0 = createElement("label");
				label0.textContent = "Rows";
				text1 = createText("\n  ");
				input0 = createElement("input");
				text2 = createText("\n  ");
				label1 = createElement("label");
				label1.textContent = "Columns";
				text4 = createText("\n  ");
				input1 = createElement("input");
				text5 = createText("\n  ");
				label2 = createElement("label");
				label2.textContent = "Symmetric";
				text7 = createText("\n  ");
				input2 = createElement("input");
				label0.className = "svelte-18cs1n8";
				addListener(input0, "input", input0_input_handler);
				input0.name = "rows";
				setAttribute(input0, "type", "number");
				input0.step = "1";
				input0.min = "2";
				input0.max = "30";
				setStyle(input0, "min-width", "50px");
				input0.className = "svelte-18cs1n8";
				label1.className = "svelte-18cs1n8";
				addListener(input1, "input", input1_input_handler);
				input1.name = "columns";
				setAttribute(input1, "type", "number");
				input1.step = "1";
				input1.min = "2";
				input1.max = "30";
				setStyle(input1, "min-width", "50px");
				input1.className = "svelte-18cs1n8";
				label2.className = "svelte-18cs1n8";
				addListener(input2, "change", input2_change_handler);
				setAttribute(input2, "type", "checkbox");
				input2.disabled = input2_disabled_value = ctx.rows !== ctx.columns;
				input2.className = "svelte-18cs1n8";
				setStyle(div, "display", "flex");
				setStyle(div, "align-items", "center");
				setStyle(div, "justify-content", "center");
				setStyle(div, "margin-bottom", "1rem");
				div.className = "svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, div, anchor);
				append(div, label0);
				append(div, text1);
				append(div, input0);

				input0.value = ctx.rows;

				append(div, text2);
				append(div, label1);
				append(div, text4);
				append(div, input1);

				input1.value = ctx.columns;

				append(div, text5);
				append(div, label2);
				append(div, text7);
				append(div, input2);

				input2.checked = ctx.symmetric;
			},

			p(changed, ctx) {
				if (!input0_updating && changed.rows) input0.value = ctx.rows;
				if (!input1_updating && changed.columns) input1.value = ctx.columns;
				if (changed.symmetric) input2.checked = ctx.symmetric;
				if ((changed.rows || changed.columns) && input2_disabled_value !== (input2_disabled_value = ctx.rows !== ctx.columns)) {
					input2.disabled = input2_disabled_value;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(input0, "input", input0_input_handler);
				removeListener(input1, "input", input1_input_handler);
				removeListener(input2, "change", input2_change_handler);
			}
		};
	}

	// (21:0) {#if showShare}
	function create_if_block_2(component, ctx) {
		var div, input, input_updating = false, text0, button0, text2, button1;

		function input_input_handler() {
			input_updating = true;
			component.set({ shareURL: input.value });
			input_updating = false;
		}

		function click_handler(event) {
			component.copy();
		}

		function click_handler_1(event) {
			component.set({showShare: false});
		}

		return {
			c() {
				div = createElement("div");
				input = createElement("input");
				text0 = createText("\n  ");
				button0 = createElement("button");
				button0.textContent = "copy";
				text2 = createText("\n  ");
				button1 = createElement("button");
				button1.textContent = "hide";
				addListener(input, "input", input_input_handler);
				setStyle(input, "flex-grow", "1");
				input.className = "svelte-18cs1n8";
				addListener(button0, "click", click_handler);
				setStyle(button0, "margin-left", "0.3rem");
				button0.className = "svelte-18cs1n8";
				addListener(button1, "click", click_handler_1);
				setStyle(button1, "margin-left", "0.3rem");
				button1.className = "svelte-18cs1n8";
				setStyle(div, "display", "flex");
				setStyle(div, "margin-bottom", "1rem");
				setStyle(div, "max-width", "600px");
				setStyle(div, "margin-left", "auto");
				setStyle(div, "margin-right", "auto");
				div.className = "svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				component.refs.share = input;

				input.value = ctx.shareURL;

				append(div, text0);
				append(div, button0);
				append(div, text2);
				append(div, button1);
			},

			p(changed, ctx) {
				if (!input_updating && changed.shareURL) input.value = ctx.shareURL;
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(input, "input", input_input_handler);
				if (component.refs.share === input) component.refs.share = null;
				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
			}
		};
	}

	// (29:0) {#if showHelp}
	function create_if_block_1(component, ctx) {
		var div;

		return {
			c() {
				div = createElement("div");
				div.innerHTML = `<p class="svelte-18cs1n8">Enter a dot make a cell black.</p>
				    <p class="svelte-18cs1n8">Navigate with arrow keys.</p>`;
				div.className = "help svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, div, anchor);
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (42:4) {#if numbers[index] !== 0}
	function create_if_block(component, ctx) {
		var span, text_value = ctx.numbers[ctx.index], text;

		return {
			c() {
				span = createElement("span");
				text = createText(text_value);
				span.className = "cell-number svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p(changed, ctx) {
				if ((changed.numbers) && text_value !== (text_value = ctx.numbers[ctx.index])) {
					setData(text, text_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (40:4) {#each values.slice(0, size) as val, index}
	function create_each_block(component, ctx) {
		var div, text0, input, input_updating = false, input_class_value, text1;

		var if_block = (ctx.numbers[ctx.index] !== 0) && create_if_block(component, ctx);

		function input_input_handler() {
			input_updating = true;
			ctx.each_value[ctx.index] = input.value;
			component.set({ values: ctx.values, size: ctx.size });
			input_updating = false;
		}

		return {
			c() {
				div = createElement("div");
				if (if_block) if_block.c();
				text0 = createText("\n    ");
				input = createElement("input");
				text1 = createText("\n    ");
				input._svelte = { component, ctx };

				addListener(input, "input", input_input_handler);
				addListener(input, "input", input_handler);
				addListener(input, "focus", focus_handler);
				addListener(input, "keyup", keyup_handler);
				input.className = input_class_value = "cell " + (ctx.blacks[ctx.index] ? 'black' : '') + " " + (ctx.values[ctx.index] === '-' ? 'empty' : '') + " svelte-18cs1n8";
				input.id = "cell-" + ctx.index;
				div.className = "cell-container svelte-18cs1n8";
			},

			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				append(div, text0);
				append(div, input);

				input.value = ctx.val;

				append(div, text1);
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if (ctx.numbers[ctx.index] !== 0) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(div, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				input._svelte.ctx = ctx;
				if (!input_updating && (changed.values || changed.size)) input.value = ctx.val;
				if ((changed.blacks || changed.values) && input_class_value !== (input_class_value = "cell " + (ctx.blacks[ctx.index] ? 'black' : '') + " " + (ctx.values[ctx.index] === '-' ? 'empty' : '') + " svelte-18cs1n8")) {
					input.className = input_class_value;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
				removeListener(input, "input", input_input_handler);
				removeListener(input, "input", input_handler);
				removeListener(input, "focus", focus_handler);
				removeListener(input, "keyup", keyup_handler);
			}
		};
	}

	function Crossword(options) {
		init(this, options);
		this.refs = {};
		this._state = assign(data(), options.data);

		this._recompute({ rows: 1, columns: 1, symmetric: 1, values: 1 }, this._state);
		this._intro = true;

		this._handlers.state = [onstate];

		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}
	}

	assign(Crossword.prototype, {
	 	destroy: destroy,
	 	get: get,
	 	fire: fire,
	 	on: on,
	 	set: set,
	 	_set: _set,
	 	_stage: _stage,
	 	_mount: _mount,
	 	_differs: _differs
	 });
	assign(Crossword.prototype, methods);

	Crossword.prototype._recompute = function _recompute(changed, state) {
		if (changed.rows || changed.columns) {
			if (this._differs(state.size, (state.size = size(state)))) changed.size = true;
		}

		if (changed.symmetric || changed.rows || changed.columns) {
			if (this._differs(state.transpose, (state.transpose = transpose(state)))) changed.transpose = true;
		}

		if (changed.rows || changed.columns || changed.values) {
			if (this._differs(state.shareURL, (state.shareURL = shareURL(state)))) changed.shareURL = true;
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function toNumber(value) {
		return value === '' ? undefined : +value;
	}

	function setAttribute(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function get() {
		return this._state;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function blankObject() {
		return Object.create(null);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function noop() {}
	return Crossword;
}());